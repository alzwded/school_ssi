Sistem de criptare dezvoltat în cadrul cursului de SSI
======================================================

Descriere de ansamblu
---------------------

Sistemul conține 4 componente:
1. Un bloc de transformări liniare modulo 256
2. O codificare într-un alfabet similar base64
3. O interclasare a textului cu o serie de caractere generate aleator
4. Un generator de numere pseudo-aleatoare

Algoritmul se folosește de un generator de numere pseudo-aleatoare intern. Parametrii sistemului de criptare sunt următorii:
1. Textul de intrare
2. O cheie secretă
3. Un număr întreg pe 32 de biți MAGIC1
4. Un număr întreg MAGIC2 reprezentând lungimea minimă a cheii
5. O permutare de dimensiune 64

Operațiile folosite sunt: sumă modulo 256, XOR și shift-ări de biți.

Algoritmul ia ca intrare un șir de octeți (spre exemplu un text codificat ASCII) iar la ieșire dă un text criptat codificat într-un sistem similar celui base64 de cel puțin două ori mai lung decât intrarea. Lungimea exactă a textului de la ieșire este în funcție de textul de intrare, cheie și ceilalți parametrii ai sistemului.

Pentru descrierea algoritmilor celor 3 componente se vor folosi următoarele notații:
* T, NT <- textul de intrare (și/sau pe care se operează) și lungimea sa
* R, NR <- text generat aleator
* K, NK <- cheia secretă și lungimea sa
* MAGIC1, MAGIC2 <- cei doi parametrii întregi pe 32 de biți ai sistemului
* ALPHBT <- alfabetul intern folosit pentru a genera textul final criptat
* PERM <- permutarea 64 aplicată alfabetului intern

De asemenea, variabile interne:
* H <- un hash calculat al cheii
* I <- un index întreg natural
* E <- un număr pseudo-aleator

Componenta 1
------------

Aceasta este prima codificare aplicată. Se operează direct pe textul de intrare, lungimea textului criptat este aceeași.

Are 4 pași:
1. Cheia este introdusă în șirul de bytes al textului clar.
1.1. Octeții de index impari sunt însumați modulo 256 cu octeții textului de intrare, pe aceleași poziții
   T(2*I) := T(2*I) + K(2*I), I = 1,NK/2
1.2. Octeții de index par ai textului de intrare sunt XOR-uiți cu suma modulo 256 a caracterului de același index al cheii împreună cu H
   Deci:
   T(2*I+1) := T(2*I+1) XOR ( K(2*I+1)+H (mod 256) ), I = 1,NK/2
2. Pornind de la indexul NK+1, caracterul de la poziția I este însumat cu cel de pe poziția I-NK și cu cel de pe poziția I-NK+MAGIC2. MAGIC2 reprezintă lungimea minimă a cheii și este un parametru al sistemului.
   T(I) := T(I) + T(I-NK) + T(I-NK+MAGIC2) (mod 256), I = NK+1,NT
3. T(I) := T(I) XOR ( H + T(NT-I+1) (mod 256) )
   T(NT-I+1) := T(NT-I+1) + T(I) (mod 256)
   I = NK+1,NT
4. T(J) := T(J) XOR T(J-1)
   J = I * (|H| (mod 4) + 1)
   I = 4,NT-4

Componenta 2
------------

Această componentă trece textul de intrare într-un alfabet de 64 de caractere. Această componentă de folosește de un generator de numere pseudo-aleatoare.

Algoritmul este:
1. Motorul de numere pseudo-aleatoare este inițializat cu parametrul MAGIC1
2. Următorul byte din textul de intrare este spart în două nibble-uri, cel semnificativ și cel mai puțin semnificativ, și se construiesc două caractere de 64 de biți în următorul fel:
2.1. Se generează următorul număr pseudo-aleator, E
2.2. Nibbleul este centrat (cel semnificativ este shiftat doi biți la dreapta, cel mai puțin semnificativ shiftat doi biți la stânga). Cel mai semnificativ este după aceea XOR-uit cu un caracter generat precedent.
2.3. Sunt alipiți doi biți pe pozițiile cele mai puțin semnificative generați în funcție de E și caracterul curent.
3. Se alipește la textul de ieșire ALPHBT(PERM(I1)) și ALPHBT(PERM(I2)), I1 și I2 fiind numerele obținute la pasul 2. Se continuă cu pasul 2. dacă mai sunt caractere.

Componenta 3
------------

Această componentă interclasează textul de intrare cu un text cu caractere din alfabetul ALPHBT după următorul algoritm:
1. Se inițializează motorul de numere aleatoare cu H
2. Se calculează lungimea maximă a textului aleator MAX = (T(1) + 1) * ((T(2) + 1) / 2) (înmulțiri și împărțiri pe numere întregi reprezentate pe 8 biți). Nu vor fi folosite mai multe caractere aleatoare decât MAX.
3. Pentru fiecare caracter din textul de intrare
3.1 Se generează următorul număr pseudo-aleator E, din care sunt luați cei mai puțin semnificativi 7 biți.
3.2 Dacă E mod 7 <= 1, atunci se alipește ALPHBT((E mod 64) + 1). Algoritmul continuă de la pasul 3.1
3.3 ...altfel, se alipește caracteul din textul de intrare la textul de ieșire și se continuă cu următorul caracter din textul de intrare.

Generatorul de numere aleatoare
-------------------------------

Generatorul poate fi descris ușor dacă este privit ca un obiect cu o stare (S) și un comportament.

Comportamentul poate fi privit ca cele două operații care pot fi aplicate generatorului de numere aleatoare. Ambele operații au ca efect modificarea stării interne.
* Inițializarea sa. Funcția de inițializare este RNGSED(N), unde N este un întreg pe 32 de biți. Operația funcționează în felul următor:
  1. se obține cea mai apropiată reprezentarea a lui N în virgulă mobile pe 32 de biți
  2. S va fi egal cu biții acestei reprezentări (N.B. aici s-a greșit în implemenarea curentă unde este reținut doar al 3lea byte din reprezentarea în virgulă mobilă. Deoarece acea aplicație serverște numai ca exemplificare și validare a inversabilității algoritmului, nu s-a considerat relevantă reîmpachetarea arhivelor)
* Obținerea umătorului număr aleator. Se calculează starea internă următoare și caracterul care va fi întors. Sunt folosite următoare operații:
  - INT(x) <- x este considerat ca un întreg cu semn pe 32 de biți
  - FLOAT(x) <- x este considerat ca un număr în virgulă mobilă pe 32 de biți
  1. S := 19073 * INT(S) + 33068 + INT(sin(FLOAT(S)))
  2. este întors al 3-lea byte (little-endian) al lui S ca rezultat

Îmbunătățiri
------------

Pot fi aduse următoarele îmbunătățiri imediate:
* îmbunătățirea algoritmului de calculare al hash-ului cheii
* îmbunătățirea algoritmului care conduce generatorul de numere pseudo-aleatoare

Desigur, pot fi aduse și alte îmbunătățiri pornind de la un studiu statistic aprofundat al comportamentului sistemului de criptare.
